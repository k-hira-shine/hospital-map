<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒãƒƒãƒ—</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Hiragino Sans', 'Yu Gothic', 'Meiryo', sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #f5f5f5;
        }

        .control-panel {
            background: white;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-bottom: 1px solid #e0e0e0;
        }

        .upload-section {
            margin-bottom: 20px;
        }

        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .upload-area:hover,
        .upload-area.dragover {
            border-color: #2196F3;
            background: #e3f2fd;
        }

        .upload-area:focus-within {
            outline: 2px solid #2196F3;
            outline-offset: 2px;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .upload-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px;
            font-size: 14px;
        }

        .upload-button:hover {
            background: #1976D2;
        }

        .upload-button:focus {
            outline: 2px solid #2196F3;
            outline-offset: 2px;
        }

        .sample-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 12px;
        }

        .sample-button:hover {
            background: #45a049;
        }

        .hint-text {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        .layers-section {
            margin-bottom: 20px;
        }

        .section-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .layer-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background: white;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.2s ease;
            user-select: none;
        }

        .layer-item:hover {
            background: #f5f5f5;
        }

        .layer-item:focus-within {
            outline: 2px solid #2196F3;
            outline-offset: -2px;
        }

        .layer-checkbox {
            margin-right: 8px;
            cursor: pointer;
        }

        .layer-checkbox:focus {
            outline: 2px solid #2196F3;
        }

        .color-chip {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid #ccc;
        }

        .layer-info {
            flex: 1;
            font-size: 14px;
        }

        .layer-name {
            font-weight: 500;
        }

        .layer-stats {
            font-size: 12px;
            color: #666;
        }

        .delete-button {
            background: #f44336;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 8px;
        }

        .delete-button:hover {
            background: #d32f2f;
        }

        .delete-button:focus {
            outline: 2px solid #f44336;
            outline-offset: 2px;
        }

        .stats-section {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .global-stats {
            font-size: 14px;
            color: #666;
        }

        .processing-indicator {
            display: none;
            color: #2196F3;
            font-size: 14px;
        }

        .processing-indicator.active {
            display: inline;
        }

        .error-list {
            margin-top: 10px;
            padding: 10px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            font-size: 12px;
            max-height: 100px;
            overflow-y: auto;
        }

        .error-list:empty {
            display: none;
        }

        .clear-button {
            background: #ff9800;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .clear-button:hover {
            background: #f57c00;
        }

        .map-container {
            flex: 1;
            position: relative;
            min-height: 400px;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        @media (max-width: 768px) {
            .control-panel {
                padding: 15px;
            }

            .stats-section {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .layer-item {
                padding: 12px;
            }

            .upload-area {
                padding: 15px;
            }
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <!-- CSV ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div class="upload-section">
            <div class="section-title">CSV ãƒ•ã‚¡ã‚¤ãƒ«è¿½åŠ </div>
            <div class="upload-area" id="uploadArea" tabindex="0" role="button" aria-label="CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ">
                <input type="file" id="fileInput" class="file-input" accept=".csv" multiple aria-label="CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ">
                <div>ğŸ“ CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯</div>
                <button class="upload-button" type="button" aria-label="ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</button>
                <button class="sample-button" id="sampleButton" type="button" aria-label="ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿">ã‚µãƒ³ãƒ—ãƒ«èª­ã¿è¾¼ã¿</button>
                <div class="hint-text">
                    å¯¾å¿œåˆ—: name, address, lat, lngï¼ˆlat/lng æŒ‡å®šæ™‚ã¯ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚­ãƒƒãƒ—ï¼‰<br>
                    æ–‡å­—ã‚³ãƒ¼ãƒ‰: UTF-8æ¨å¥¨ã€ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œå¿…é ˆ
                </div>
            </div>
        </div>

        <!-- ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç† ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div class="layers-section">
            <div class="section-title">ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†</div>
            <div class="layer-list" id="layerList" role="list" aria-label="ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ¬ã‚¤ãƒ¤ãƒ¼ä¸€è¦§">
                <!-- ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¤ãƒ†ãƒ ãŒã“ã“ã«å‹•çš„è¿½åŠ ã•ã‚Œã‚‹ -->
            </div>
        </div>

        <!-- çµ±è¨ˆãƒ»ã‚¨ãƒ©ãƒ¼è¡¨ç¤º ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div class="stats-section">
            <div class="global-stats" id="globalStats">
                ç·è¡Œæ•°: 0 | æˆåŠŸ: 0 | å¤±æ•—: 0
            </div>
            <div class="processing-indicator" id="processingIndicator" aria-live="polite">
                å‡¦ç†ä¸­...
            </div>
            <button class="clear-button" id="clearAllButton" type="button" aria-label="å…¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å‰Šé™¤">å…¨å‰Šé™¤</button>
        </div>
        <div class="error-list" id="errorList" role="alert" aria-live="polite"></div>
    </div>

    <!-- ãƒãƒƒãƒ—è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
    <div class="map-container">
        <div id="map" role="application" aria-label="Google ãƒãƒƒãƒ—"></div>
    </div>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let map;
        let geocoder;
        const layers = [];
        const colors = [
            '#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5',
            '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50',
            '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800'
        ];
        let nextLayerId = 1;
        let globalStats = { total: 0, success: 0, failed: 0 };
        const geocodeQueue = [];
        let isProcessingQueue = false;
        const failedItems = [];
        let currentRetryDelay = 200;
        const duplicateKeys = new Set();

        // åˆæœŸåŒ–
        function initMap() {
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 35.6804, lng: 139.7690 },
                zoom: 11,
                mapTypeControl: true,
                streetViewControl: true,
                fullscreenControl: true
            });

            geocoder = new google.maps.Geocoder();
            setupEventListeners();
            
            // ç›¸æ¨¡åŸåŒ»ç™‚æ©Ÿé–¢ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•èª­ã¿è¾¼ã¿
            loadSagamiharaMedicalFacilities();
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        function setupEventListeners() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            const sampleButton = document.getElementById('sampleButton');
            const clearAllButton = document.getElementById('clearAllButton');

            // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
            uploadArea.addEventListener('click', (e) => {
                if (e.target !== fileInput) {
                    fileInput.click();
                }
            });

            uploadArea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    fileInput.click();
                }
            });

            // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files).filter(file => 
                    file.type === 'text/csv' || file.name.toLowerCase().endsWith('.csv')
                );
                if (files.length > 0) {
                    handleFiles(files);
                }
            });

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFiles(Array.from(e.target.files));
                }
            });

            // ã‚µãƒ³ãƒ—ãƒ«ãƒœã‚¿ãƒ³
            sampleButton.addEventListener('click', loadSampleData);

            // å…¨å‰Šé™¤ãƒœã‚¿ãƒ³
            clearAllButton.addEventListener('click', clearAllLayers);

            // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
            window.addEventListener('error', (e) => {
                console.error('Global error:', e.error);
                addFailedItem('ã‚·ã‚¹ãƒ†ãƒ ', 0, `æœªæ•æ‰ã‚¨ãƒ©ãƒ¼: ${e.message}`);
                updateStats();
            });
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†
        function handleFiles(files) {
            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const csvText = e.target.result;
                        const layerName = file.name.replace(/\.[^/.]+$/, "");
                        processCSV(csvText, layerName);
                    } catch (error) {
                        console.warn('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                        addFailedItem(file.name, 0, `èª­ã¿è¾¼ã¿å¤±æ•—: ${error.message}`);
                        updateStats();
                    }
                };
                reader.readAsText(file, 'UTF-8');
            });
        }

        // CSV ãƒ‘ãƒ¼ã‚¹ï¼ˆç°¡æ˜“å®Ÿè£…ï¼‰
        function parseCSV(csvText) {
            const lines = csvText.split(/\r?\n/);
            const result = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const fields = [];
                let current = '';
                let inQuotes = false;
                
                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    const nextChar = line[j + 1];
                    
                    if (char === '"') {
                        if (inQuotes && nextChar === '"') {
                            current += '"';
                            j++; // æ¬¡ã®æ–‡å­—ã‚’ã‚¹ã‚­ãƒƒãƒ—
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        fields.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                fields.push(current.trim());
                result.push(fields);
            }
            
            return result;
        }

        // CSV å‡¦ç†
        function processCSV(csvText, fileName) {
            const data = parseCSV(csvText);
            if (data.length < 2) {
                addFailedItem(fileName, 0, 'ãƒ˜ãƒƒãƒ€ãƒ¼ã¾ãŸã¯ãƒ‡ãƒ¼ã‚¿è¡ŒãŒä¸è¶³');
                updateStats();
                return;
            }

            const headers = data[0].map(h => h.toLowerCase());
            const nameIndex = headers.indexOf('name');
            const addressIndex = headers.indexOf('address');
            const latIndex = headers.indexOf('lat');
            const lngIndex = headers.indexOf('lng');

            if (nameIndex === -1 || addressIndex === -1) {
                addFailedItem(fileName, 0, 'name ã¾ãŸã¯ address åˆ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                updateStats();
                return;
            }

            const layer = makeLayer(fileName);
            const validRows = [];

            for (let i = 1; i < data.length; i++) {
                const row = data[i];
                if (row.length < Math.max(nameIndex, addressIndex) + 1) {
                    addFailedItem(fileName, i + 1, 'å¿…è¦ãªåˆ—æ•°ãŒä¸è¶³');
                    continue;
                }

                const name = row[nameIndex]?.trim();
                const address = row[addressIndex]?.trim();

                if (!name || !address) {
                    addFailedItem(fileName, i + 1, 'name ã¾ãŸã¯ address ãŒç©º');
                    continue;
                }

                const lat = latIndex !== -1 ? parseFloat(row[latIndex]) : null;
                const lng = lngIndex !== -1 ? parseFloat(row[lngIndex]) : null;

                const duplicateKey = `${name}|${address}${lat && lng ? `|${lat},${lng}` : ''}`;
                if (duplicateKeys.has(duplicateKey)) {
                    addFailedItem(fileName, i + 1, 'é‡è¤‡ãƒ‡ãƒ¼ã‚¿');
                    continue;
                }
                duplicateKeys.add(duplicateKey);

                validRows.push({
                    name,
                    address,
                    lat: !isNaN(lat) ? lat : null,
                    lng: !isNaN(lng) ? lng : null,
                    rowNumber: i + 1
                });
            }

            layer.stats.total = validRows.length;
            addLayerFromRows(layer, validRows, fileName);
        }

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½œæˆ
        function makeLayer(name) {
            const layer = {
                id: nextLayerId++,
                name: name,
                color: colors[(layers.length) % colors.length],
                markers: [],
                rows: [],
                visible: true,
                stats: { total: 0, success: 0, failed: 0 }
            };
            layers.push(layer);
            return layer;
        }

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãƒãƒ¼ã‚«ãƒ¼è¿½åŠ 
        function addLayerFromRows(layer, rows, fileName) {
            if (rows.length === 0) {
                updateStats();
                renderLayerList();
                return;
            }

            showProcessingIndicator(true);
            
            rows.forEach(row => {
                layer.rows.push(row);
                globalStats.total++;
                
                if (row.lat && row.lng) {
                    // åº§æ¨™ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ç›´æ¥ãƒãƒ¼ã‚«ãƒ¼è¿½åŠ 
                    addMarker(layer, row.name, row.address, row.lat, row.lng);
                    layer.stats.success++;
                    globalStats.success++;
                } else {
                    // ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒå¿…è¦
                    enqueueGeocode(layer, row, fileName);
                }
            });

            updateStats();
            renderLayerList();
            
            if (geocodeQueue.length > 0) {
                processQueue();
            } else {
                showProcessingIndicator(false);
                fitToVisibleBounds();
            }
        }

        // ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° ã‚­ãƒ¥ãƒ¼è¿½åŠ 
        function enqueueGeocode(layer, row, fileName) {
            geocodeQueue.push({
                layer: layer,
                row: row,
                fileName: fileName,
                retries: 0
            });
        }

        // ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° ã‚­ãƒ¥ãƒ¼å‡¦ç†
        function processQueue() {
            if (isProcessingQueue || geocodeQueue.length === 0) {
                return;
            }

            isProcessingQueue = true;
            processNextInQueue();
        }

        function processNextInQueue() {
            if (geocodeQueue.length === 0) {
                isProcessingQueue = false;
                showProcessingIndicator(false);
                fitToVisibleBounds();
                return;
            }

            const item = geocodeQueue.shift();
            const address = item.row.address;

            geocoder.geocode({ address: address }, (results, status) => {
                if (status === 'OK' && results[0]) {
                    const location = results[0].geometry.location;
                    addMarker(item.layer, item.row.name, item.row.address, location.lat(), location.lng());
                    item.layer.stats.success++;
                    globalStats.success++;
                    updateStats();
                } else if (status === 'OVER_QUERY_LIMIT' || status === 'REQUEST_DENIED') {
                    // ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚¨ãƒ©ãƒ¼ã®å‡¦ç†
                    if (item.retries < 3) {
                        item.retries++;
                        geocodeQueue.unshift(item); // ã‚­ãƒ¥ãƒ¼ã®å…ˆé ­ã«æˆ»ã™
                        currentRetryDelay = Math.min(currentRetryDelay * 2, 3200); // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
                        setTimeout(processNextInQueue, currentRetryDelay);
                        return;
                    } else {
                        addFailedItem(item.fileName, item.row.rowNumber, `ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å¤±æ•—: ${status}`);
                        item.layer.stats.failed++;
                        globalStats.failed++;
                        updateStats();
                    }
                } else {
                    addFailedItem(item.fileName, item.row.rowNumber, `ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å¤±æ•—: ${status}`);
                    item.layer.stats.failed++;
                    globalStats.failed++;
                    updateStats();
                }

                // æ¬¡ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‡¦ç†ï¼ˆåŸºæœ¬é–“éš”ï¼‰
                setTimeout(processNextInQueue, 200);
            });
        }

        // ãƒãƒ¼ã‚«ãƒ¼è¿½åŠ 
        function addMarker(layer, name, address, lat, lng) {
            const marker = new google.maps.Marker({
                position: { lat: lat, lng: lng },
                map: layer.visible ? map : null,
                title: name,
                icon: makeMarkerIcon(layer.color)
            });

            const infoWindow = new google.maps.InfoWindow({
                content: `<div><strong>${name}</strong><br>${address}</div>`
            });

            marker.addListener('click', () => {
                infoWindow.open(map, marker);
            });

            layer.markers.push(marker);
        }

        // ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ¼ã‚«ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ä½œæˆ
        function makeMarkerIcon(color) {
            const svg = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="8" fill="${color}" stroke="white" stroke-width="2"/>
                </svg>
            `;
            return {
                url: `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(svg)}`,
                scaledSize: new google.maps.Size(24, 24),
                anchor: new google.maps.Point(12, 12)
            };
        }

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒªã‚¹ãƒˆè¡¨ç¤ºæ›´æ–°
        function renderLayerList() {
            const layerList = document.getElementById('layerList');
            layerList.innerHTML = '';

            layers.forEach(layer => {
                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item';
                layerItem.setAttribute('role', 'listitem');
                layerItem.setAttribute('tabindex', '0');
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = layer.visible;
                checkbox.className = 'layer-checkbox';
                checkbox.setAttribute('aria-label', `${layer.name}ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ`);

                const colorChip = document.createElement('div');
                colorChip.className = 'color-chip';
                colorChip.style.backgroundColor = layer.color;

                const layerInfo = document.createElement('div');
                layerInfo.className = 'layer-info';
                layerInfo.innerHTML = `
                    <div class="layer-name">${layer.name}</div>
                    <div class="layer-stats">æˆåŠŸ: ${layer.stats.success} / å¤±æ•—: ${layer.stats.failed}</div>
                `;

                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-button';
                deleteButton.textContent = 'å‰Šé™¤';
                deleteButton.setAttribute('aria-label', `${layer.name}ã‚’å‰Šé™¤`);

                layerItem.appendChild(checkbox);
                layerItem.appendChild(colorChip);
                layerItem.appendChild(layerInfo);
                layerItem.appendChild(deleteButton);

                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
                attachLayerRowHandlers(layerItem, layer, checkbox, deleteButton);

                layerList.appendChild(layerItem);
            });
        }

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡Œã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
        function attachLayerRowHandlers(layerItem, layer, checkbox, deleteButton) {
            let longPressTimer;
            let isIsolated = false;

            // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹
            checkbox.addEventListener('change', (e) => {
                e.stopPropagation();
                toggleLayerVisibility(layer.id);
            });

            // å‰Šé™¤ãƒœã‚¿ãƒ³
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                removeLayer(layer.id);
            });

            // è¡Œã‚¯ãƒªãƒƒã‚¯
            layerItem.addEventListener('click', (e) => {
                if (e.target === checkbox || e.target === deleteButton) return;
                toggleLayerVisibility(layer.id);
            });

            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ
            layerItem.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    toggleLayerVisibility(layer.id);
                }
            });

            // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯
            layerItem.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                isolateLayer(layer.id);
            });

            // é•·æŠ¼ã—ï¼ˆãƒã‚¦ã‚¹ï¼‰
            layerItem.addEventListener('mousedown', (e) => {
                if (e.target === checkbox || e.target === deleteButton) return;
                longPressTimer = setTimeout(() => {
                    showAllLayers();
                }, 600);
            });

            layerItem.addEventListener('mouseup', () => {
                clearTimeout(longPressTimer);
            });

            layerItem.addEventListener('mouseleave', () => {
                clearTimeout(longPressTimer);
            });

            // é•·æŠ¼ã—ï¼ˆã‚¿ãƒƒãƒï¼‰
            layerItem.addEventListener('touchstart', (e) => {
                if (e.target === checkbox || e.target === deleteButton) return;
                longPressTimer = setTimeout(() => {
                    showAllLayers();
                }, 600);
            });

            layerItem.addEventListener('touchend', () => {
                clearTimeout(longPressTimer);
            });
        }

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
        function toggleLayerVisibility(layerId) {
            const layer = layers.find(l => l.id === layerId);
            if (!layer) return;

            layer.visible = !layer.visible;
            layer.markers.forEach(marker => {
                marker.setMap(layer.visible ? map : null);
            });

            renderLayerList();
            fitToVisibleBounds();
        }

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼å˜ç‹¬è¡¨ç¤º
        function isolateLayer(layerId) {
            const targetLayer = layers.find(l => l.id === layerId);
            if (!targetLayer) return;

            // ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆç¢ºèª
            const hasSnapshot = layers.some(l => l.originalVisibilitySnapshot !== undefined);

            if (hasSnapshot) {
                // ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‹ã‚‰å¾©å…ƒ
                layers.forEach(layer => {
                    if (layer.originalVisibilitySnapshot !== undefined) {
                        layer.visible = layer.originalVisibilitySnapshot;
                        delete layer.originalVisibilitySnapshot;
                    }
                });
            } else {
                // ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆä½œæˆã—ã¦å˜ç‹¬è¡¨ç¤º
                layers.forEach(layer => {
                    layer.originalVisibilitySnapshot = layer.visible;
                    layer.visible = (layer.id === layerId);
                });
            }

            // ãƒãƒ¼ã‚«ãƒ¼è¡¨ç¤ºæ›´æ–°
            layers.forEach(layer => {
                layer.markers.forEach(marker => {
                    marker.setMap(layer.visible ? map : null);
                });
            });

            renderLayerList();
            fitToVisibleBounds();
        }

        // å…¨ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤º
        function showAllLayers() {
            layers.forEach(layer => {
                layer.visible = true;
                delete layer.originalVisibilitySnapshot;
                layer.markers.forEach(marker => {
                    marker.setMap(map);
                });
            });

            renderLayerList();
            fitToVisibleBounds();
        }

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼å‰Šé™¤
        function removeLayer(layerId) {
            const layerIndex = layers.findIndex(l => l.id === layerId);
            if (layerIndex === -1) return;

            const layer = layers[layerIndex];
            
            // ãƒãƒ¼ã‚«ãƒ¼å‰Šé™¤
            layer.markers.forEach(marker => {
                marker.setMap(null);
            });

            // é‡è¤‡ã‚­ãƒ¼ã‹ã‚‰ã“ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤
            layer.rows.forEach(row => {
                const duplicateKey = `${row.name}|${row.address}${row.lat && row.lng ? `|${row.lat},${row.lng}` : ''}`;
                duplicateKeys.delete(duplicateKey);
            });

            // çµ±è¨ˆæ›´æ–°
            globalStats.total -= layer.stats.total;
            globalStats.success -= layer.stats.success;
            globalStats.failed -= layer.stats.failed;

            // ãƒ¬ã‚¤ãƒ¤ãƒ¼é…åˆ—ã‹ã‚‰å‰Šé™¤
            layers.splice(layerIndex, 1);

            updateStats();
            renderLayerList();
            fitToVisibleBounds();
        }

        // å…¨ãƒ¬ã‚¤ãƒ¤ãƒ¼å‰Šé™¤
        function clearAllLayers() {
            if (layers.length === 0) return;

            if (!confirm('ã™ã¹ã¦ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;

            layers.forEach(layer => {
                layer.markers.forEach(marker => {
                    marker.setMap(null);
                });
            });

            layers.length = 0;
            duplicateKeys.clear();
            globalStats = { total: 0, success: 0, failed: 0 };
            failedItems.length = 0;

            updateStats();
            renderLayerList();
        }

        // è¡¨ç¤ºç¯„å›²èª¿æ•´
        function fitToVisibleBounds() {
            const visibleLayers = layers.filter(l => l.visible);
            if (visibleLayers.length === 0) return;

            const bounds = new google.maps.LatLngBounds();
            let hasMarkers = false;

            visibleLayers.forEach(layer => {
                layer.markers.forEach(marker => {
                    bounds.extend(marker.getPosition());
                    hasMarkers = true;
                });
            });

            if (hasMarkers) {
                map.fitBounds(bounds);
                if (map.getZoom() > 15) {
                    map.setZoom(15);
                }
            }
        }

        // çµ±è¨ˆæ›´æ–°
        function updateStats() {
            const globalStatsElement = document.getElementById('globalStats');
            globalStatsElement.textContent = 
                `ç·è¡Œæ•°: ${globalStats.total} | æˆåŠŸ: ${globalStats.success} | å¤±æ•—: ${globalStats.failed}`;

            updateErrorList();
        }

        // ã‚¨ãƒ©ãƒ¼ãƒªã‚¹ãƒˆæ›´æ–°
        function updateErrorList() {
            const errorList = document.getElementById('errorList');
            if (failedItems.length === 0) {
                errorList.innerHTML = '';
                return;
            }

            const displayItems = failedItems.slice(0, 5);
            errorList.innerHTML = `
                <strong>ã‚¨ãƒ©ãƒ¼ä¾‹ (å…ˆé ­${displayItems.length}ä»¶):</strong><br>
                ${displayItems.map(item => 
                    `${item.fileName}:${item.rowNumber} - ${item.reason}`
                ).join('<br>')}
                ${failedItems.length > 5 ? `<br>...ä»– ${failedItems.length - 5} ä»¶` : ''}
            `;
        }

        // å¤±æ•—é …ç›®è¿½åŠ 
        function addFailedItem(fileName, rowNumber, reason) {
            failedItems.push({ fileName, rowNumber, reason });
            globalStats.failed++;
            console.warn(`Failed item: ${fileName}:${rowNumber} - ${reason}`);
        }

        // å‡¦ç†ä¸­ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼
        function showProcessingIndicator(show) {
            const indicator = document.getElementById('processingIndicator');
            indicator.classList.toggle('active', show);
        }

        // ç›¸æ¨¡åŸåŒ»ç™‚æ©Ÿé–¢ãƒ‡ãƒ¼ã‚¿è‡ªå‹•èª­ã¿è¾¼ã¿
        function loadSagamiharaMedicalFacilities() {
            fetch('./sagamihara-medical-facilities.csv')
                .then(response => response.text())
                .then(csvText => {
                    processCSV(csvText, "ç›¸æ¨¡åŸå¸‚è‡ªç«‹æ”¯æ´åŒ»ç™‚æ©Ÿé–¢");
                })
                .catch(error => {
                    console.warn('ç›¸æ¨¡åŸåŒ»ç™‚æ©Ÿé–¢ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
                    loadSampleData();
                });
        }

        // ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
        function loadSampleData() {
            const sampleData = [
                { name: "æœ¬ç¤¾", address: "æ±äº¬éƒ½åƒä»£ç”°åŒºåƒä»£ç”°1-1" },
                { name: "å€‰åº«", address: "ç¥å¥ˆå·çœŒå·å´å¸‚éº»ç”ŸåŒºç‹ç¦…å¯ºæ±" }
            ];

            const layer = makeLayer("ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿");
            const rows = sampleData.map((item, index) => ({
                name: item.name,
                address: item.address,
                lat: null,
                lng: null,
                rowNumber: index + 1
            }));

            layer.stats.total = rows.length;
            addLayerFromRows(layer, rows, "ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿");
        }
    </script>

    <!-- Google Maps API èª­ã¿è¾¼ã¿ -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCk362YNjFjHr1Z8af2VcRdLH51SKhVSbY&language=ja&callback=initMap"></script>
</body>
</html>

<!--
GitHub Pages ãƒ‡ãƒ—ãƒ­ã‚¤æ‰‹é †:
1. ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒªãƒã‚¸ãƒˆãƒªç›´ä¸‹ã« index.html ã¨ã—ã¦é…ç½®
2. GitHub ãƒªãƒã‚¸ãƒˆãƒªã® Settings â†’ Pages â†’ Source ã§ "Deploy from a branch" ã‚’é¸æŠ
3. Branch ã§ "main" (ã¾ãŸã¯ãƒ¡ã‚¤ãƒ³ãƒ–ãƒ©ãƒ³ãƒ) ã‚’é¸æŠ
4. æ•°åç§’å¾Œã«å…¬é–‹ URL ãŒç™ºè¡Œã•ã‚Œã¾ã™
5. Google Maps API ã‚­ãƒ¼ã‚’ YOUR_API_KEY ã‹ã‚‰å®Ÿéš›ã®ã‚­ãƒ¼ã«å·®ã—æ›¿ãˆã¦ãã ã•ã„
6. API ã‚­ãƒ¼ã«ã¯ HTTP ãƒªãƒ•ã‚¡ãƒ©åˆ¶é™ï¼ˆGitHub Pages ã®å…¬é–‹ URLï¼‰ã‚’è¨­å®šã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™
7. URL ã‚’å…±æœ‰ã—ã¦åˆ©ç”¨ã—ã¦ãã ã•ã„ï¼ˆæ¤œç´¢ã‚¨ãƒ³ã‚¸ãƒ³ã‚’é¿ã‘ãŸã„å ´åˆã¯ head ã« <meta name="robots" content="noindex"> ã‚’è¿½åŠ å¯èƒ½ï¼‰
-->
